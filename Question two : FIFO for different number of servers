
import simpy
import random
import numpy as np
import matplotlib.pyplot as plt

#For our plots, we picked lambda and muu to get different values of rho, such as p=0.7,0.8,0.9,p=0.95.

lambdaa = 1.5  # Let's suppose we get one customer per unit of time.
mu = 2         # Let's assume that one server is able to treat two clients per unit of time, so one client takes a half of the unit of time to be served, which would reduce the waiting time
nbserver = [1, 2, 4]  # Asked by the problem
# p=lambdaa/n*mu (to not forget the formula for the charge)
time = 1000  # Time of the simulation
waitingtime = []
# We pick lambdaa and mu, so we can have p close to one but still inferior, it makes the dynamics more interesting

def customerprocessing(env, clientnumber, server):
    arrival_time = env.now  # This is when the customer arrives (the time)
    inter_arrival_time = random.expovariate(lambdaa)  # We know that lambda and mu both follow an exponential law
    yield env.timeout(inter_arrival_time)  # Basically we yield out until the next customer arrives
    # print("The customer",clientnumber,"arrives at",arrival_time) : used to test the code 
    with server.request() as request:  # We request an available server
        yield request  # If a server is available, the customer processing keeps going, if no one is available, the customer has to wait
        wait_time = env.now - arrival_time  
        waitingtime.append(wait_time) 
        # print("The customer is starting to get served at",wait_time) used to test the code
        service_time = random.expovariate(mu)
        yield env.timeout(service_time)  
        # print("The customer",clientnumber,"leaves the service/shop at",env.now)

#This is a simple example of the fct to run our simulation. However, we will need more simulations to see an actual significant result
def simulation(n):
    global waitingtime 
    waitingtime = [] 
    
    # We create the environment of simulation with simpy
    env = simpy.Environment()
     
    # We create our server resource
    server = simpy.Resource(env, capacity=n)
    
    # We simulate for a defined number of customers
    for i in range(1, 60):  # 60 customers
        env.process(customerprocessing(env, i, server))
    
    # We start the simulation
    env.run(until=time)  
    
    # We return the mean of waiting time
    return np.mean(waitingtime)

# That's the function where we can see more significant results by repeating the simulation to get an average waiting time for a precise number of servers
def simulationcomplex(n, itermax):
    global waitingtime  
    all_wait_times = []  

    for _ in range(itermax):
        waitingtime = []  
        env = simpy.Environment() 
        server = simpy.Resource(env, capacity=n) 
        
        for i in range(1,60): #60 customers
            env.process(customerprocessing(env, i, server))
        
        env.run(until=time)  
        
        all_wait_times.append(np.mean(waitingtime))

    # Now we compute the mean and standard deviation
    mean_waiting_time = np.mean(all_wait_times)
    std_dev = np.std(all_wait_times)  
    
    return mean_waiting_time, std_dev

# Now, we have to check out if what we proved in question one was right, so we have to study this problem for different number of servers, here, we have : nbserver=[1,2,4] as asked by the problem
results = {}
for n in nbserver:
    avg_wait_time = simulation(n)  # Calcul du temps d'attente moyen pour cette configuration
    results[n] = avg_wait_time
    print("Average waiting time for",n,"servers:",avg_wait_time)
    
# We plot our results for the simple simulation
plt.plot(nbserver, [results[n] for n in nbserver], marker='o')
plt.title('Average waiting time for different numbers of servers')
plt.xlabel("Number of servers")
plt.ylabel("Average waiting time")
plt.grid(True)
plt.show()


resultscomplex = {}
for n in nbserver:
    mean_wait_time, std_dev = simulationcomplex(n, 500)  
    resultscomplex[n] = mean_wait_time
    print("Average waiting time for,",n,"servers:",mean_wait_time, "±", std_dev)

#We plot our results for the more complex simulation
plt.plot(nbserver, [resultscomplex[n] for n in nbserver], marker='o')
plt.title('Average waiting time for the complex simulation in fct of the number of servers')
plt.xlabel("Number of servers")
plt.ylabel("Average waiting time")
plt.grid(True)
plt.show()

#How does the number of measurements required to attain this depend on ρ?
#I will add this in the report, but from what I understand if p is close to one, you are going to have unstable results (it would be worse if p>1) because the servers are super busy, so the waiting time is gonna fluctuate, so that's why you need way more simulations to have solid results. If p is small compared to one, then it's fine, you don't need that simulation. I'll run this code for multiple values of p by varying lambdaa and mu, so we can observe this ourselves. 
